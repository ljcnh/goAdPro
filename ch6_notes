snowflake算法 (数据id+时间信息)
    int64
    1：符号位  41：时间戳   5：数据中心的id    5：机器实例id   12：循环自增id
             timestamp   datacenter_id    worker_id     sequence_id

    datacenter_id 可以在部署阶段轻松地获取到
    worker_id 是我们逻辑上给机器分配的一个id，
        比较简单的想法是由能够提供这种自增id功能的工具来支持
        也可以更简单暴力一些，把worker_id直接写在worker的配置中，上线时，由部署脚本完成worker_id字段替换。


定时器的实现：
时间堆
    最常见的时间堆一般用小顶堆实现，小顶堆其实就是一种特殊的二叉树
    四叉堆
        小顶堆的性质，父节点比其4个子节点都小，子节点之间没有特别的大小关系要求
时间轮
    定义每一个格子的“刻度”，可以将时间轮想像成一个时钟，中心有秒针顺时针转动。每次转动到一个刻度时，我们就需要去查看该刻度挂载的任务列表是否有已经到期的任务


任务分发
    每一个实例每隔一小时，会去数据库里把下一个小时需要处理的定时任务捞出来，捞取的时候只要取那些task_id % shard_count = shard_id的那些任务即可。
    当这些定时任务被触发之后需要通知用户侧，有两种思路：
        将任务被触发的信息封装为一条消息，发往消息队列，由用户侧对消息队列进行监听。
        对用户预先配置的回调函数进行调用。

数据再平衡和幂等考量

倒排列表（ES 确实牛逼）


异构数据同步
    很少直接向搜索引擎中写入数据，一般将MySQL或其它关系型数据中的数据同步到搜索引擎中，而搜索引擎的使用方只能对数据进行查询，无法进行修改和删除
    两种方法
        通过时间戳进行增量数据同步
        通过 binlog 进行数据同步
            业界使用较多的是阿里开源的Canal，来进行binlog解析与同步。

负载均衡
    常见的负载均衡思路
        按顺序挑
        随机挑一个
        根据某种权重，对下游节点进行排序，选择权重最大/小的那一个
    基于洗牌算法的负载均衡
